; A deque (double-ended queue) as defined by the following set of items:
; A constructor: (make-deque)
; A predicate: (empty-deque? <deque>)
; Two selectors (front-deque <deque>) (rear-deque <deque>)
; Four mutators:  (front-insert-deque! <deque> <item>)  (front-delete-deque! <deque>)
;                 (rear-insert-deque! <deque> <item>)  (rear-delete-deque! <deque>)


; inner helper operations
(define (set-front-ptr! deque p)
  (set-car! deque p))
(define (set-rear-ptr! deque p)
  (set-cdr! deque p))

(define (make-deque) (cons '() '()))
(define (front-ptr deque) (car deque))
(define (rear-ptr deque) (cdr deque))

(define (empty-deque? deque)
  (or (eq? (front-ptr deque) '())
      (eq? (rear-ptr deque) '())))
(define (front-deque deque)
  (front-ptr deque))
(define (rear-deque deque)
  (rear-ptr deque))
(define (front-insert-deque! deque item)
  (let ((data-pair (cons item '())))
    (if (empty-deque? deque)
      (let ((ptr-pair (cons data-pair '())))
        (set-front-ptr! deque ptr-pair)
        (set-rear-ptr! deque ptr-pair)
        deque)
      (let ((first-data-pair (car (front-deque deque)))
            (ptr-pair (cons data-pair (front-deque deque))))
        (set-cdr! first-data-pair ptr-pair)
        (set-front-ptr! deque ptr-pair)
        deque))))
(define (rear-insert-deque! deque item)
  (let ((data-pair (cons item '())))
    (if (empty-deque? deque)
      (let ((ptr-pair (cons data-pair '())))
        (set-front-ptr! deque ptr-pair)
        (set-rear-ptr! deque ptr-pair)
        deque)
      (let ((last-data-ptr (rear-deque deque))
            (ptr-pair (cons data-pair '())))
        (set-cdr! data-pair last-data-ptr)
        (set-cdr! last-data-ptr ptr-pair)
        (set-rear-ptr! deque ptr-pair)
        deque))))

(define (front-delete-deque! deque)
  (if (empty-deque? deque)
    (error "DELETE on empty deque")
    (let ((first-ptr (front-deque deque)))
      (let ((second-ptr (cdr first-ptr)))
        (if (null? second-ptr)
          (begin
            (set-front-ptr! deque '())
            deque)
          (begin
            (set-cdr! (car second-ptr) '())
            (set-front-ptr! deque second-ptr)
            deque))))))

(define (rear-delete-deque! deque)
  (if (empty-deque? deque)
    (error "DELETE on empty deque")
    (let ((last-ptr (rear-deque deque)))
      (let ((second-ptr (cdar last-ptr)))
        (if (null? second-ptr)
          (begin
            (set-rear-ptr! deque '())
            deque)
          (begin
            (set-cdr! second-ptr '())
            (set-rear-ptr! deque second-ptr)
            deque))))))

(define (print-deque deque)
  (define (iter l)
    (if (null? l)
      '()
      (cons (caar l) (iter (cdr l)))))
  (if (empty-deque? deque)
    '()
    (iter (front-ptr deque))))

(define dq (make-deque))
(front-insert-deque! dq 1)
(front-insert-deque! dq 2)
(front-insert-deque! dq 3)
(front-delete-deque! dq)

; (rear-insert-deque! dq 3)
; (rear-delete-deque! dq)
; (print-deque dq)

; (load "deque.scm")
